name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: write  # For creating releases and tags
  pull-requests: write
  security-events: write  # Required for SARIF upload
  packages: write  # For Docker push

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.1'
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Run unit tests
        run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Run integration tests
        run: go test -v -run TestIntegration ./...

      - name: Generate coverage report
        run: go tool cover -html=coverage.out -o coverage.html

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.html

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.1'
          cache: true

      - name: Run go vet
        run: go vet ./...

      - name: Run staticcheck
        uses: dominikh/staticcheck-action@v1
        with:
          version: "latest"
          install-go: false

      - name: Run golangci-lint
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.64.8
          golangci-lint run --timeout=5m

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.1'

      - name: Run gosec
        uses: securego/gosec@master
        with:
          args: '-no-fail -fmt sarif -out gosec-results.sarif ./...'

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: gosec-results.sarif
        if: always()

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, lint, security]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.1'
          cache: true

      - name: Clone CoreDNS
        run: |
          git clone --depth 1 --branch v1.13.2 https://github.com/coredns/coredns.git
          cd coredns

      - name: Register plugin
        run: |
          cd coredns
          # Add elchi plugin to plugin.cfg after kubernetes
          sed -i '/kubernetes:kubernetes/a elchi:github.com/cloudnativeworks/elchi-gslb' plugin.cfg

          # Replace local module
          echo "replace github.com/cloudnativeworks/elchi-gslb => ../" >> go.mod

          # Download dependencies
          go mod tidy

      - name: Build CoreDNS with elchi plugin
        run: |
          cd coredns
          CGO_ENABLED=0 go build -v -ldflags="-s -w" -o ../coredns-elchi

      - name: Verify binary
        run: |
          ./coredns-elchi -version || true
          file coredns-elchi
          ls -lh coredns-elchi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: coredns-elchi-linux-amd64
          path: coredns-elchi

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [test, lint, security, build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      release_created: ${{ steps.check_release.outputs.created }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get version from VERSION file
        id: get_version
        run: |
          VERSION=$(cat VERSION)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Version: ${VERSION}"

      - name: Check if release exists
        id: check_release
        run: |
          VERSION=${{ steps.get_version.outputs.version }}
          if gh release view "v${VERSION}" >/dev/null 2>&1; then
            echo "created=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Release v${VERSION} already exists"
          else
            echo "created=true" >> $GITHUB_OUTPUT
            echo "âœ… Will create release v${VERSION}"
          fi

      - name: Create and push tag
        if: steps.check_release.outputs.created == 'true'
        run: |
          VERSION=${{ steps.get_version.outputs.version }}
          if ! git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            git tag -a "v${VERSION}" -m "Release version ${VERSION}"
            git push origin "v${VERSION}"
            echo "âœ… Tag v${VERSION} created"
          fi

      - name: Generate changelog
        if: steps.check_release.outputs.created == 'true'
        id: changelog
        run: |
          VERSION=${{ steps.get_version.outputs.version }}
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 "v${VERSION}^" 2>/dev/null || echo "")

          if [ -n "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"* %s (%h)" ${PREVIOUS_TAG}..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"* %s (%h)")
          fi

          echo "${CHANGELOG}" > /tmp/changelog.txt

      - name: Download binary artifact
        if: steps.check_release.outputs.created == 'true'
        uses: actions/download-artifact@v4
        with:
          name: coredns-elchi-linux-amd64
          path: ./artifacts

      - name: Create GitHub Release
        if: steps.check_release.outputs.created == 'true'
        run: |
          VERSION=${{ steps.get_version.outputs.version }}
          CHANGELOG=$(cat /tmp/changelog.txt)

          # Create source archive
          ARCHIVE_NAME="elchi-gslb-v${VERSION}"
          git archive --format=tar.gz --prefix=${ARCHIVE_NAME}/ -o ${ARCHIVE_NAME}.tar.gz HEAD

          # Rename binary with version
          mv ./artifacts/coredns-elchi ./artifacts/coredns-elchi-linux-amd64-v${VERSION}
          chmod +x ./artifacts/coredns-elchi-linux-amd64-v${VERSION}

          # Create release notes
          {
            echo "## Elchi GSLB CoreDNS Plugin v${VERSION}"
            echo ""
            echo "### What's Changed"
            echo ""
            echo "${CHANGELOG}"
            echo ""
            echo "### Installation"
            echo ""
            echo "#### Using Docker"
            echo ""
            echo '```bash'
            echo "docker pull cloudnativeworks/elchi-coredns:v${VERSION}"
            echo "docker pull cloudnativeworks/elchi-coredns:latest"
            echo '```'
            echo ""
            echo "#### Download Binary (Linux AMD64)"
            echo ""
            echo '```bash'
            echo "wget https://github.com/cloudnativeworks/elchi-gslb/releases/download/v${VERSION}/coredns-elchi-linux-amd64-v${VERSION}"
            echo "chmod +x coredns-elchi-linux-amd64-v${VERSION}"
            echo "sudo mv coredns-elchi-linux-amd64-v${VERSION} /usr/local/bin/coredns"
            echo '```'
            echo ""
            echo "#### From Source"
            echo ""
            echo '```bash'
            echo "curl -L https://github.com/cloudnativeworks/elchi-gslb/archive/refs/tags/v${VERSION}.tar.gz -o elchi-gslb-v${VERSION}.tar.gz"
            echo "tar -xzf elchi-gslb-v${VERSION}.tar.gz"
            echo "cd elchi-gslb-v${VERSION}"
            echo "make build"
            echo '```'
            echo ""
            echo "### CoreDNS Version"
            echo ""
            echo "Built with CoreDNS v1.13.2"
            echo ""
            echo "### Documentation"
            echo ""
            echo "- [README](https://github.com/cloudnativeworks/elchi-gslb/blob/v${VERSION}/README.md)"
          } > /tmp/release_notes.md

          # Create release with binary and source archive
          gh release create "v${VERSION}" \
            --title "Elchi GSLB v${VERSION}" \
            --notes-file /tmp/release_notes.md \
            ${ARCHIVE_NAME}.tar.gz \
            ./artifacts/coredns-elchi-linux-amd64-v${VERSION}

          echo "âœ… Release v${VERSION} created"

  docker-amd64:
    name: Build AMD64 Docker Image
    runs-on: ubuntu-22.04
    needs: release
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.release.outputs.release_created == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.1'
          cache: false

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push AMD64 image
        env:
          DOCKER_BUILDKIT: 1
          VERSION: ${{ needs.release.outputs.version }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          IMAGE_NAME="${DOCKER_USERNAME}/elchi-coredns"
          IMAGE_TAG="${IMAGE_NAME}:v${VERSION}-amd64"

          docker buildx build \
            --no-cache \
            --platform linux/amd64 \
            --build-arg "COREDNS_VERSION=v1.13.2" \
            --build-arg "TARGETARCH=amd64" \
            -t "${IMAGE_TAG}" \
            -f Dockerfile \
            --load \
            .

          docker push "${IMAGE_TAG}"

          echo "âœ… AMD64 image: ${IMAGE_TAG}"

  docker-arm64:
    name: Build ARM64 Docker Image
    runs-on: self-hosted
    needs: release
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.release.outputs.release_created == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.1'
          cache: false

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push ARM64 image
        env:
          DOCKER_BUILDKIT: 1
          VERSION: ${{ needs.release.outputs.version }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          IMAGE_NAME="${DOCKER_USERNAME}/elchi-coredns"
          IMAGE_TAG="${IMAGE_NAME}:v${VERSION}-arm64"

          docker buildx build \
            --no-cache \
            --platform linux/arm64 \
            --build-arg "COREDNS_VERSION=v1.13.2" \
            --build-arg "TARGETARCH=arm64" \
            -t "${IMAGE_TAG}" \
            -f Dockerfile \
            --load \
            .

          docker push "${IMAGE_TAG}"

          echo "âœ… ARM64 image: ${IMAGE_TAG}"

  docker-manifest:
    name: Create Multi-arch Manifest
    runs-on: ubuntu-22.04
    needs: [release, docker-amd64, docker-arm64]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.release.outputs.release_created == 'true'
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Create multi-platform manifest
        env:
          VERSION: ${{ needs.release.outputs.version }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          IMAGE_NAME="${DOCKER_USERNAME}/elchi-coredns"
          MANIFEST_TAG="${IMAGE_NAME}:v${VERSION}"
          LATEST_TAG="${IMAGE_NAME}:latest"

          # Create versioned manifest
          docker manifest create "${MANIFEST_TAG}" \
            "${IMAGE_NAME}:v${VERSION}-amd64" \
            "${IMAGE_NAME}:v${VERSION}-arm64"
          docker manifest push "${MANIFEST_TAG}"

          # Create latest manifest
          docker manifest create "${LATEST_TAG}" \
            "${IMAGE_NAME}:v${VERSION}-amd64" \
            "${IMAGE_NAME}:v${VERSION}-arm64"
          docker manifest push "${LATEST_TAG}"

          echo "âœ… Multi-platform manifests created"
          echo "ðŸ“¦ ${MANIFEST_TAG}"
          echo "ðŸ“¦ ${LATEST_TAG}"
